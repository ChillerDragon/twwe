import { LRParser } from '@lezer/lr';
import { LRLanguage, foldNodeProp, LanguageSupport } from '@codemirror/language';
import { styleTags, tags } from '@lezer/highlight';

// This file was generated by lezer-generator. You probably shouldn't edit it.
const parser = LRParser.deserialize({
  version: 14,
  states: "(QQYQPOOO_QPO'#C`OdQPO'#C_OOQO'#DQ'#DQQYQPOOOOQO,58z,58zOrQPO'#CeOOQO'#DR'#DROwQPO'#CdO!PQPO'#ChO!UQPO'#CgOOQO'#Cd'#CdO!mQPO'#CcOOQO,58y,58yOOQO-E7O-E7OOOQO,59P,59POOQO-E7P-E7POOQO,59O,59OO!xQPO,59SO#WQPO'#CpO#]QQO'#CzO#bQPO'#C}OOQO'#DT'#DTO#gQPO,59RO$OQPO'#DPOwQPO'#DUO$TQPO,58}OOQO'#Cl'#ClOOQO'#DS'#DSO$`QPO'#CkOOQO1G.n1G.nO$qQPO1G.nO$vQPO,59[O${QPO,59fOOQO,59i,59iOOQO-E7R-E7ROOQO,59k,59kOOQO,59p,59pOOQO-E7S-E7SOOQO-E7Q-E7QOOQO7+$Y7+$YO%QQPO1G.vOOQO1G/Q1G/QO%`QPO'#CuOOQO'#Cr'#CrO%eQPO7+$bO%jQPO'#CxOOQO,59a,59aOOQO<<G|<<G|O%`QPO,59dO&OQPO,59dOOQO1G/O1G/OO%`QPO1G/OOOQO7+$j7+$j",
  stateData: "&Z~O{OSPOS~OTPO~OUTO~OYUO]XOTRXyRX~OU_O~OYUO]XO~O^bO~OYUOecOodOreOTZXyZX}ZX~O}hOTVXyVX~OUnOakObkOckO~O^pO~OpqO~OUrO~OYUOecOodOreOTZayZa}Za~OUtO~O}hOTVayVa~OakObkOckOU_Xm_X~OUxO~O^yO~OUzO~Og|Oh|Oj{Ok{O~O^!OO~OU!QO~OakObkOckOm!RO|!SOUlX~Om!UOUla~OPU~",
  goto: "$SyPPPz!OPP!S!V!]P!f!mPP!r!xPPP!bP!}PP#QPP#TP!bPP!bP#^#b#h#o#v#|TROSTQOSR]QQ[QRuiUVQWiTfYgSZQiRaWVYQWiQobR!S!OVlbm!OR}yR|yQ!P{Q!T!RR!V!UTi[jQSOR^SSWQiR`WSmb!ORwmQgYRsgQj[Rvj",
  nodeNames: "âš  Comment file Config Header HeaderTok EndLine Runs Run NoLayerCopy NoLayerCopy IndexRules IndexRule Index Int Orient Flag XFLIP YFLIP ROTATE Pos Pos PosRule EMPTY FULL TileSpec INDEX NOTINDEX SpecList OR Random Random Float NoDefaultRule NoDefaultRule NewRun",
  maxTerm: 45,
  skippedNodes: [0,1],
  repeatNodeCount: 5,
  tokenData: "/`~RaYZ!Wpq!]st!b{|!y}!O!y!O!P#S!Q![#x!g!h$Y!h!i$w!k!l%`!p!q&i!q!r+b!r!s+m!t!u,O!z!{-e!{!|.S!}#O.q~!]OU~~!bO{~~!gSP~OY!bZ;'S!b;'S;=`!s<%lO!b~!vP;=`<%l!bQ!|Q!O!P#S!Q![#jQ#VP!Q![#YQ#_QpQuv#e!Q![#YQ#jOpQQ#oRpQuv#e!O!P#Y!Q![#jR$PRpQ^Puv#e!O!P#Y!Q![#x~$]P!o!p$`~$cP!r!s$f~$iP!v!w$l~$oP!{!|$r~$wOg~~$zP!w!x$}~%QP!n!o%T~%WP!n!o%Z~%`Oh~~%cQ!p!q%i#b#c&Q~%lP!f!g%o~%rP!g!h%u~%xP!z!{%{~&QOj~~&TP#W#X&W~&ZP#X#Y&^~&aP#l#m&d~&iO]~~&lR!q!r&u#X#Y(O#c#d(m~&xQ!p!q'O!v!w'Z~'RP!g!h'U~'ZO|~~'^P!k!l'a~'dP!p!q'g~'jP!f!g'm~'pP!g!h's~'vP!z!{'y~(OOk~~(RP#k#l(U~(XP!t!u([~(_P#i#j(b~(eP#b#c(h~(mO}~~(pQ!f!g(v!n!o*Z~(yP#X#Y(|~)PP#Y#Z)S~)VP#T#U)Y~)]P#i#j)`~)cP#`#a)f~)iP#h#i)l~)oP!t!u)r~)uP#i#j)x~){P#`#a*O~*RP#X#Y*U~*ZOr~~*^P#T#U*a~*dP#m#n*g~*jP#X#Y*m~*pP#f#g*s~*vP!e!f*y~*|P#c#d+P~+SP#d#e+V~+YP#m#n+]~+bOY~~+eP!t!u+h~+mOm~~+pP#c#d+s~+vP#g#h+y~,OOe~~,RQ!q!r,X#T#U,v~,[P!v!w,_~,bP!c!d,e~,hP!v!w,k~,nP!g!h,q~,vOc~~,yP#b#c,|~-PP#W#X-S~-VP#c#d-Y~-]P#a#b-`~-eOo~~-hP!h!i-k~-nP!n!o-q~-tP!k!l-w~-zP!r!s-}~.SOa~~.VP!h!i.Y~.]P!n!o.`~.cP!k!l.f~.iP!r!s.l~.qOb~~.tTO#P.q#P#Q/T#Q;'S.q;'S;=`/Y<%lO.q~/YOT~~/]P;=`<%l.q",
  tokenizers: [0, 1],
  topRules: {"file":[0,2]},
  tokenPrec: 238
});

function foldDDNetConfig(node) {
    var _a, _b;
    const from = (_b = (_a = node.firstChild) === null || _a === void 0 ? void 0 : _a.firstChild) === null || _b === void 0 ? void 0 : _b.to; // end of HeaderTok
    const to = node.to - 1; // before newline
    if (from) {
        return { from, to };
    }
    else {
        return null;
    }
}
const DDNetRulesLanguage = LRLanguage.define({
    parser: parser.configure({
        props: [
            foldNodeProp.add({
                Config: foldDDNetConfig
            }),
            styleTags({
                Header: tags.heading,
                Int: tags.integer,
                Float: tags.float,
                Comment: tags.lineComment,
                EndLine: tags.invalid,
                "NewRun": tags.keyword,
                "Index": tags.keyword,
                "Pos": tags.keyword,
                "Random": tags.keyword,
                "NoDefaultRule": tags.keyword,
                "NoLayerCopy": tags.keyword,
                "XFLIP": tags.modifier,
                "YFLIP": tags.modifier,
                "ROTATE": tags.modifier,
                "INDEX": tags.modifier,
                "NOTINDEX": tags.modifier,
                "EMPTY": tags.modifier,
                "FULL": tags.modifier,
                "OR": tags.modifier,
            })
        ]
    }),
    languageData: {
        commentTokens: { line: "#" }
    }
});
function DDNetRules() {
    return new LanguageSupport(DDNetRulesLanguage);
}

export { DDNetRules, DDNetRulesLanguage };
